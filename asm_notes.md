## [Little-endian / Big-endian](https://en.wikipedia.org/wiki/Endianness)
* **Endianness** - the order or sequence of bytes of a word of digital data in computer memory.
  Endianness is primarily expressed as big-endian (BE) or little-endian (LE).

![Endian](https://user-images.githubusercontent.com/55103017/125188165-76434500-e23b-11eb-8d0d-4f2c4612add6.PNG) \
[src](https://en.wikipedia.org/wiki/File:Big-Endian.svg)

## Структура команд Ассемблера
* **Инструкция** - набор чисел, представляющий собой закодированную функцию процессора. В ее состав входит операция и операнды.
* **Операция** - определяет вид инструкции (сложение, запись в память и т.д.)
* **Операнды** - аргументы операции
  * От 0 до 3-х
  * **Непосредственный операнд**
    * **Числовая константа**
    * **Символ**
  * **Указатель на ячейку памяти**
  * **Неявный операнд** - операнд, не фиксирующийся в исходном коде инстркуции,
    но входящий в логику ее работы (к примеру, закрепленный за инструкцией регистр) - должен быть задокументирован
* **Суффикс** - суффикс операции, указывающий на размер всех операндов
  * `b` (byte) - 1B
  * `w` (word) - 2B
  * `l` (long) - 4B
  * `q` (quad) - 8B

## Символы и метки
* **Символ** - некоторая константа. Хранится в объектном файле, используется для наименования констант, переменных, функций и т.д. Имеет характеристики:
  * тип: `a` - absolute value, `t` - in text section, `D` - global in, data section, ...
  * имя - привязанное к символу наименование
  * константа - значение символа
```
[user@host:~]$ nm hello.o
00000000 d hello_str
0000000e a hello_str_length
00000000 T main
```
* **Метка** - символ, значение которого - адрес памяти. Используется для упорядочивания инструкций в программе.
  * `.` - текущее значение адреса
  * `string:` - создает метку с именем "string"
```
hello_str:
 .string "Hello, world!\n"
```

## Директивы Ассемблера
Директивы размещают данные в памяти. Их аргументы - список выражений, разделенных запятыми.

## Директивы для работы с символами
* `.set` *`symbol`*, *`expression`* - создает новый символ
* `.globl` *`symbol`* - сделать символ *`symbol`* глобальным

### Директивы для размещения числовых констант
* `.byte` - размещают каждое выражение как 1B
* `.short` - 2B
*  `.long` - 4B
*  `.quad` - 8B
```
.byte 0x10, 0xf5, 0x42, 0x55
.long 0xaabbaabb
.short -123, 456
```
### Директивы для размещения строковых [литералов](https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0))
* `.ascii` *`"STR"`* - размещает *`STR`* в памяти без добавления нулевого байта `\0`
* `.string` *`"STR"`* - размещает *`STR`* в памяти с добавленияем нулевого байта `\0`
```
.string "Hello, world\n"
```
### Директивы секций
* `.data` - секция данных
* `.section .rodata` - секция для хранения read only data
* `.bss` - секция неинициализированных данных

### Директива заполнения, выравнивания
* `.space` *`кол-во байт`*, *`заполнитель`* - резервирует *`кол-во байт`*, инициализируя их *`заполнитель`* (опционально)
* `.p2align` *`степень 2`*, *`заполнитель`*, *`максимум`* - выравнивает текущий адрес до заданной границы. Граница
выравнивания задаётся как степень числа 2: например, если вы указали `.p2align 3` —
следующее значение будет выровнено по **8-байтной** границе. Для выравнивания
размещается необходимое количество байт-заполнителей со значением заполнитель.
Если для выравнивания требуется разместить **более** чем максимум байт-заполнителей,
то выравнивание **не выполняется**.

## Регистры
* **Общего назначения (general purpose)**
  * x86-64
    * `rax` (8B), `eax` (least 4B of rax), `ax` (least 2B of eax), `ah` (high 1B of ax), `al` (least 1B of ax)
    * `rbx`, `rcx`, `rdx`
    * `rsp` (stack pointer), `rbp` (stack base pointer)
    * `rsi` (src idx reg), `rdi` (dst idx reg)
* **Сегментные регистры**
  * x86-64
    * `cs` - code segment
    * `ds` - data segment
    * `ss` - stack segment
    * `es` - extra segment
    * `fs` - F segment
    * `gs` - G segment
* **Регистр флагов**
  * x86-64
    * [`rflags`](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80_%D1%84%D0%BB%D0%B0%D0%B3%D0%BE%D0%B2)
      * `CF` - carry flag
      * `PF` - parity flag
      * `ZF` - zero flag
      * `SF` - sign flag
      * `OF` - overflow flag
      * `AC` - alignment check
      * `AF`, `TF`, `IF`, `DF`, `IOPL`, `NT`, `RF`, `VM`, `VIF`, `VIP`, `ID`
* **Регистр текущей команды**
  * x86-64 (not available directly)
    * `rip` - instruction pointer


## Stack
  * стэк растет в сторону убывания адресов
  * вершина стека (stack pointer) динамична
  * дно стека (base pointer) статично - начало стекового фрейма
  * `push`
    1. `rsp` -= sizeof(elem) bytes
    2. записать элемент по адресу, на который указывает значение в регистре rsp
  * `pop`
    1. записать элемент по адресу, на который указывает значение в регистре rsp
    2. `rsp` += sizeof(elem) bytes
  * `call` *`label`*
    1. Поместить в стек (`push`) адрес следующей за `call` команды (адрес возврата, берется из `rip`)
    2. Передать управление указанной метке (*`label`*)
  * `ret` / `ret` *`number`*
    1. Извлечь из стека адрес возврата (`pop`)
    2. Передать управление команде, расположенной по адресу возврата
    3. `rsp` += *`number`* (optional - need to forget func arguments)
